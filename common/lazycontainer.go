package common

import (
	"sync"
	"sync/atomic"
	"unsafe"
)

// LazyContainer is a lazy datastructure that allows a single evaluation of a given function
type LazyContainer struct {
	// Get returns the value generated by the function (computes it if needed)
	Get func() unsafe.Pointer
}

const (
	empty        uint32 = iota
	gettingReady
	ready
)

// NewLazyContainer returns a LazyContainer that will contain the result of the given fonction
func NewLazyContainer(f func() unsafe.Pointer) *LazyContainer {
	lc := LazyContainer{}
	var content unsafe.Pointer
	var mtx sync.Mutex

	status := empty

	prepare := func() unsafe.Pointer {
		mtx.Lock()
		value := f()
		atomic.StorePointer(&content, value)

		// next getters doesn't need to look at any lock
		defer atomic.StoreUint32(&status, ready)
		defer mtx.Unlock()
		return value
	}

	lc.Get = func() unsafe.Pointer {
		if atomic.LoadUint32(&status) != ready {
			if atomic.CompareAndSwapUint32(&status, empty, gettingReady) {
				return prepare()
			}
			// IT IS GETTING READY
			// tries to acquire the lock and release it
			for atomic.LoadUint32(&status) != ready {
				mtx.Lock()
				defer mtx.Unlock()
				return atomic.LoadPointer(&content)
			}
		}

		return atomic.LoadPointer(&content)
	}

	return &lc
}
